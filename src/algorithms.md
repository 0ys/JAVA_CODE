## 알고리즘 정리
|   구분    | 알고리즘              | 시간복잡도    | 구현 유형         | 사용 기법          |
|:---------:|:------------------|----------|---------------|----------------|
| 완전 탐색 | DFS               | N^2      | List, 배열      | stack, 재귀      |
|           | BFS               | N^2      | List, 배열      | Queue          |
|           | 백트래킹              |          | List, 배열      |                |
|  최적화   | 분할정복              | NlogN    | 배열            |                |
|           | 동적계획법 DP          | N        | 배열            | 메모제이션, <br>점화식 |
|           | 슬라이딩 윈도우          | N        | 배열, Deque     |                |
|           | Greedy            |          | List, 배열      |                |
| 자료구조  | 우선순위큐             | NlogN    | List          |                |
|           | Union Find        | N        | List, 배열      |                |
|           | 이진탐색              | logN     | 배열            |                |
|           | lower/upper bound | logN     | 배열            |                |
|   수학    | 유클리드 호제법          |          |               |                |
|           | 확장 유클리드 호제법       |          |               |                |
|           | 에라토스테네스의 체        |          |               |                |
|           | 파스칼의 삼각형          |          |               |                |


|       구분        | 알고리즘                    | 확장 알고리즘                      | 시간복잡도 | 구현유형   | 사용기법              | 간선방향        |
|:---------------:|-------------------------| ---------------------------------- | ---------- | ---------- | --------------------- | --------------- |
|       트리        | LCA<br>(공통조상찾기)         |                                    | NlogN      | List       |                       |                 |
|                 | 인덱스트리<br>(Segment Tree) | 펙웍트리(BIT)<br>Lazy Propagation  | NlogN      | 배열       | 이진탐색              |                 |
|  그래프 <br>최단경로   | 다익스트라                   |                                    | ElogV      | List, 배열 | 우선순위큐            | 방향,<br>무방향 |
|                 | 벨만포드                    |                                    | VE         | List, 배열 | 완전탐색<br>음수가능  | 방향,<br>무방향 |
|                 | 플로이드-워셜                 |                                    | V^3        | 배열       | 완전탐색<br>음수가능  | 방향,<br>무방향 |
| 최소신장<br>트리(MST) | 크루스칼 Kruscal            |                                    | ElogV      | List, 배열 | 탐욕법,<br>UnionFind  | 무방향          |
|                 | 프림 Prim                 |                                    | V^2        | List, 배열 | 탐욕법,<br>우선순위큐 | 무방향          |
|       그래프       | 위상정렬                    |                                    | V+E        | List, 배열 | DAG                   | 방향            |
|                 | 단절점, 단절선                | 강한 연결 요소<br>- 타잔, 코사라주 | V+E        | List, 배열 |                       | 무방향          |


## 알고리즘 문제풀이 기초
- 히든케이스(Edge 검사) : 기본 테스트케이스 외에도 끝 값이나 시작 값으로 검사해보기
- 모든 테스트 케이스를 통과했는데도 틀린다면, 자료형을 고려!(int를 long으로)
- 20억이 넘어가면 자료형 long을 사용하자.
- 
- 1억 연산은 1초를 의미한다. 즉, 만*만이 넘어가면 틀린거임
- 자바는 실수를 double을 기본으로 사용한다.
- int 배열은 1억건 이상 넘어가면 힘들다.
- `연산 횟수 = 알고리즘 시간 복잡도 * 데이터의 크기`
- 예를 들어, 시간제한이 2초(2억번 연산)일 때, 데이터가 1,000,000이라면 N*N은 사용할 수 없다.
- 
- 100,000 이상의 데이터를 처리할 때 N*N 알고리즘은 어렵다.
- 1,000,000인 데이터를 처리할 때는 NlogN 알고리즘을 사용
- 5,000,000인 데이터일 경우, NlogN 알고리즘 사용 불가(단순 정렬은 가능)하므로 O(n) 알고리즘을 사용해야함

### 시간복잡도 문제 해결
1. 알맞은 알고리즘을 선택
   - 데이터와 시간 제한을 보고 그에 맞는 알고리즘을 선택해야 함
2. 내 코드를 살펴보기
   - 알고리즘이 맞았는데 시간초과가 나는 경우, 내 코드에 비효율적인 부분이 없는지 살펴봐야 함

#### 코드트리 예시 : 제한시간이 1초일때
- N<=10 : N!, 2^N, 3^N
- N<=20 : 2^N
- N<=100 : N^4
- N<=500 : N^3
- N<=1,000 : N^2, N^2logN
- N<=100,000 : N, NlogN, logN, O(1)

## 정렬의 응용
1. 유일성 검사/ 중복 제거
   - Set도 같은 역할을 함 = treeSet(정렬이 되는 Set)
2. 빈도 구하기(logN)
   - lower bound ~ upper bound
3. 합집합/교집합 구하기
   - 2 pointers 알고리즘을 이용
4. 이분 탐색(log N) = priority queue
   1. Array.binarySearch를 사용
   2. N이 10만대이면 NlogN 알고리즘을 사용

---
## 깊이 우선 탐색 DFS O(V+E)
그래프 완전 탐색 기법 중 하나이다.
깊이 우선 탐색은 그래프의 시작 노드부터 시작하여 탐색 분기의 최대 깊이까지 탐색을 마친 후 다른 쪽 분기로 이동하여 다시 탐색을 수행한다.
시간 복잡도는 O(V+E)로 V는 노드의 개수, E는 엣지의 개수를 의미한다.
DFS는 재귀함수 또는 스택 자료구조로 구현한다. 즉 DFS는 재귀 함수 그 자체로 생각할 수 있다.

* 응용 문제
- 백트래킹
- 단절선 찾기
- 단절점 찾기
- 위상 정렬
- 사이클 찾기



## 너비 우선 탐색 BFS
간선의 가중치가 모두 동일할 때, BFS로 탐색함
ArrayDeque를 사용.
- 최단 경로 찾기
- 위상 정렬


---
## 인덱스 트리 O(MlogN)
2042 구간 합 구하기 참고
1. 구간 left, right가 주어졌을 때, A[left] + A[left+1] + ... + A[r-1] + A[r]
2. i번째 수 A[i]를 V로 바꾸어라 = update

트리를 저장하는 1차원 배열은 2^n * 2 크기로 선언한다.\
왜냐하면 리프 노트의 개수가 N개 이상이 되도록 높이 T인 트리 배열을 만들어야 함\
배열의 0번째는 사용하지 않는다.\
그래서 리프 노드가 8개라면 arr[16]으로 선언하고 0번째 배열을 제외한 15개의 노드를 사용함\
리프 포인터를 설정해서 리프 노드를 저장하고 업데이트할 때 사용함

parent index = current index/2

---
## 정수론
### 유클리드 호제법
2개의 자연수의 최대공약수(GCD)를 구하는 알고리즘의 하나이다.\
2개의 자연수 a, b에 대해 a를 b로 나눈 나머지를 r이라 하면(단, a>b), a와 b의 최대공약수는 b와 r의 최대공약수와 같다는 성질을 이용한다.\
즉, `gcd(a, b) = gcd(b, a%b) (단, a>=b)`이다.\
#### 세 개 이상의 정수의 최대 공약수를 구하는 방법
유클리드 호제법을 재귀적으로 사용한다. 
`gcd(A, B, C) = gcd(gcd(A, B), C)`를 이용한다.
구현은 아래와 같다.
```java
static int gcd(int a, int b){
    if(b==0) return a;
    return gcd(b, a%b);
}
```

### 확장 유클리드 호제법
정수 x, y의 최대 공약수를 gcd(x,y)로 나타낼 때, 확장 유클리드 호제법을 이용하여, 
ax + by = gcd(x,y)의 해가 되는 정수 a, b의 짝을 찾아낼 수 있다. (a, b 중 한개는 보통 음수가 된다.) 
이 식을 베주의 항등식이라고 한다. 
특히 x, y가 서로소(gcd(x,y)=1)인 경우 유용하다. 이 경우, ax+by=1이 되고, 여기서 a는 모듈로 연산의 곱의 역원이 되기 때문이다.

### 소수 구하기 - 에라토스테네스의 체
소수를 찾으면 해당하는 소수의 배수들을 모두 지워줌으로써 지워지지 않은 숫자를 찾는다.


























